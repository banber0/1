#
    ##在 MemorySet 中添加 mmap 和 munmap 的底层逻辑。
        mmap: 检查对齐，将 syscall 的权限位转换为内核的 MapPermission，检查虚拟地址是否与现有区域冲突，若无冲突则压入新的 MapArea。
        munmap: 遍历现有区域，找到包含目标范围的区域。根据目标范围是覆盖整个区域、切掉尾部还是切掉头部，执行相应的解映射操作。
        在process.rs中实现 sys_get_time、sys_mmap 和 sys_munmap。
        mport: 引入 MemorySet 相关的辅助函数以及获取当前任务的模块，sys_get_time: 使用 translated_byte_buffer 将内核的 TimeVal 写入用户态指针。需要处理跨页的情况，sys_mmap/sys_munmap: 获取当前任务的 memory_set 并调用刚才实现的方法。
    ##对代码进行编译报错
        task/mod.rs 报错，在文件末尾定义了全局函数 current_mmap，但没有在 impl TaskManager 结构体实现块中定义对应的方法
        任何 pub 的函数都必须写 /// 文档注释。

    简答：
        1.
        V (Valid, Bit 0): 有效位。为 1 表示该页表项有效；为 0 表示无效。
        R (Read, Bit 1): 可读位。允许读取该页面。
        W (Write, Bit 2): 可写位。允许写入该页面。
        X (Execute, Bit 3): 可执行位。允许从该页面取指执行。
        U (User, Bit 4): 用户位。为 1 表示允许在用户态访问；为 0 表示仅允许在内核态访问。
        G (Global, Bit 5): 全局位。为 1 表示该页面是全局的，TLB 刷新时不会清除该项。
        A (Accessed, Bit 6): 访问位。当该页面被读、写或取指时，硬件自动将其置为 1。用于页面置换算法。
        D (Dirty, Bit 7): 脏位。当该页面被写入时，硬件自动将其置为 1。表示页面被修改过，换出时需要写回磁盘。
        2.
        取指缺页，读缺页，写缺页
        大致占用 20MB 左右的内存
        访问时触发缺页：用户进程访问该地址，由于页表中 V=0，触发 Page Fault 异常，进入内核陷阱处理程序，内核读取 stval 获取出问题的虚拟地址，内核检查该地址是否位于进程记录的合法 VMA 范围内。如果是合法地址：内核立即分配一个物理帧，将内容（清零或从磁盘读取）填充进去，并修改页表，建立映；
        如果是非法地址则杀死进程。
        3.
        当调度器决定从进程 A 切换到进程 B 时，OS 修改 satp 寄存器，将其指向进程 B 的根页表物理地址，并执行 sfence.vma 刷新 TLB。
        对于内核使用的页面高地址部分，在页表项中设置 U = 0；对于用户使用的页面低地址部分，在页表项中设置 U = 1。
        单页表优势：减少了TLB刷新，性能高，在用户态和内核态切换时，不需要切换页表，因此不需要刷新 TLB，开销小；数据交互方便：内核可以直接访问用户态的内存地址，在读取用户传来的系统调用参数时非常方便，无需进行软件地址转换。
        双叶表在用户态 -> 内核态、内核态 -> 用户态、进程 A -> 进程 B时进行更换，单页表只在进程切换时更换
#在修改报错时候费了很多时间，有很多细节还是没有注意到，对代码理解还不透彻，接下来继续向后做ch5